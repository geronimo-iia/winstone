List of other things to do:
---------------------------

	
	- inverse control of all unmanaged bean.
	But without spring/pico container, we would using ServiceLoader availaible on jdk6.
	
	- find a better way to manage log
	May we use log4J and :	
	The AsyncAppender lets users log events asynchronously.
	The AsyncAppender will collect the events sent to it and then dispatch them to all the appenders that are attached to it. You can attach multiple appenders to an AsyncAppender.
	The AsyncAppender uses a separate thread to serve the events in its buffer.
	AsyncAppender uses separate thread for logging purpose. As such it is not blocking the execution thread.
	
	- Key Store
	In winstone.ssl.HttpListener#getSSLContext():
	---
	KeyStore ks = KeyStore.getInstance("JKS");
	---
	Only "JKS" can be use, but I would like to use other KeyStore type.
	---
	KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
	---
	or
	---
	private static String keyStoreType; // set by command line option.
	KeyStore ks = KeyStore.getInstance(this.keyStoreType);
	---


	-- Incorrect decoding of URL in getServletPath()
	Details:
	HttpServletRequest.getServletPath() decodes URL incorrectly. Specifically, it decodes '+' to ' ', which is just defined for query string but not for the URL in general.
	The bug is in WebAppConfiguration.java line 1279. From what it seems like you need a different version of the decodeURLToken() method.
	See http://en.wikipedia.org/wiki/Query_string#URL_encoding

	- URL escape is UTF-8, not iso-8859-1
	When request URL includes URL escape (%HH), it needs to be decoded as UTF-8, not iso-8859-1. 
	See RFC 3986 section 2.5 for the authoritative specification.


	- WinstoneInputStream performance problem?
	I'm an experienced programmer, but unfortunately I don't know much about client/server communications, so forgive my attempt at explaining the problem.
	The Winstone servlet is reading data streamed from the client and the stream is a GZipInputStream. In this case the servlet seems to process the data quite slowly (at least compared to Jetty or Tomcat). When I pause the execution in a debugger, it most often stops in WinstoneInputStream.read(). Now, maybe I'm not properly identifying the root cause of the problem, but there is definitely a performance problem somewhere.
	Thanks for listening and thanks for a great (and very light!) servlet.

	Upon further testing (and looking at the source code), I think I see the
	problem. I'm streaming a 300MB zip file to the server. While reading the
	stream, the "dump" data member in WinstoneInputStream grows and grows and I
	think it may cause a lot of garbage collection and, eventually, may even
	cause an OutOfMemory exception. It doesn't look like the dump data is ever
	even used.


	
	- Unable to include a servlet with the RequestDispatcher
	
	There is a issue with RequestDispatcher.include() in Winstone 0.9.10 which prevents the inclusion of another servlet. 
	It looks like the included servlet overwrites the buffer of the calling servlet, 
	and if the calling servlet first flushes the output before including the other servlet, 
	an IllegalStateException is thrown with the message : "Called RequestDispatcher.forward() on committed response". 
	This issue also breaks the usage of the jsp:include tag.
	
	Here is an example :
	
	Servlet A :
	
	response.getWriter().println("INCLUDED CONTENT");
	
	Servlet B :
	
	response.setContentType("text/plain");
	response.getWriter().println("PRE INCLUDE");
	
	request.getRequestDispatcher("/path/to/servletA").include(request, response);
	
	response.getWriter().println("POST INCLUDE");
	response.getWriter().flush();
	
	Calling the servlet B displays only "INCLUDED CONTENT", the pre/pst message aren't in the response body. 
	And flushing the output before calling RequestDispatcher.include() throws an IllegalStateException :
	
	Add a response.flushBuffer(); ?
	
	java.lang.IllegalStateException: Called RequestDispatcher.forward() on committed response
	at winstone.RequestDispatcher.forward(RequestDispatcher.java:263)
	at winstone.invoker.InvokerServlet.doGet(InvokerServlet.java:134)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:104)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:45)
	at winstone.ServletConfiguration.execute(ServletConfiguration.java:249)
	at winstone.RequestDispatcher.include(RequestDispatcher.java:200)
	at ServletB.doGet(ServletA.java:29)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:104)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:45)
	at winstone.ServletConfiguration.execute(ServletConfiguration.java:249)
	at winstone.RequestDispatcher.forward(RequestDispatcher.java:335)
	at winstone.invoker.InvokerServlet.doGet(InvokerServlet.java:134)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:104)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:45)
	at winstone.ServletConfiguration.execute(ServletConfiguration.java:249)
	at winstone.RequestDispatcher.forward(RequestDispatcher.java:335)
	at winstone.RequestHandlerThread.processRequest(RequestHandlerThread.java:244)
	at winstone.RequestHandlerThread.run(RequestHandlerThread.java:150)
	at java.lang.Thread.run(Thread.java:619)
	


Long-term
     - Control port password ? Maybe not, or only if someone asks for it
     - Add more automated tests as part of release process:
       - url matching (evaluation of servletPath/pathInfo)
       - security / authentication
       - cluster resilience
       - ajp13 connector
     - More complete manual/documentation
     - Publish apidocs
     - Eclipse plug-in ? internal launcher plus browser window, and project level config for 
         winstone properties
     - More accurate profiling of memory usage, object allocation etc
     - Auto-deployer for webappsDir folder. Redeploy warfiles that have been updated or added
     - Maven winstone plugin, so we can run maven winstone, and it will war-up and execute
